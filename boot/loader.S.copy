%include "boot.inc"
section loader vstart=LOADER_BASE_ADDR
LOADER_STACK_TOP equ LOADER_BASE_ADDR
jmp loader_start

;构建gdt及其内部的描述符
GDT_BASE: 
	dd 0x00000000
	dd 0x00000000
CODE_DESC:
	dd 0x0000FFFF
	dd DESC_CODE_HIGH4
DATA_STACK_DESC:
	dd 0x0000FFFF
	dd DESC_DATA_HIGH4
VIDEO_DESC:
	dd 0x80000007	;limit=(0xbffff-0xb8000)/4K=0x7
	dd DESC_VIDEO_HIGH4	;此时dpl为0
GDT_SIZE equ $-GDT_BASE
GDT_LIMIT equ GDT_SIZE-1
times 60 dq 0	;此处预留30个描述符的空位,预留60个就超过512B，调整的地方就比较多了

;total_mem_bytes 用于保存内存容量，以字节为单位，此位置比较好记
;当前偏移 loader.bin 文件头 0x200字节，故total_mem_bytes 内存中的地址是 0xb00，将来在内存中引用此地址
total_mem_bytes dd 0

SELECTOR_CODE	equ (0x0001<<3) + TI_GDT + RPL0	;相当于 (CODE_DESC-GDT_BASE)/8 + TI_GDT + RPL0
SELECTOR_DATA	equ (0x0002<<3) + TI_GDT + RPL0	;同上
SELECTOR_VIDEO	equ (0x0003<<3) + TI_GDT + RPL0	;同上

;下面是 gdt 的指针，前2字节是 gdt 界限，后4字节是 gdt 起始地址
gdt_ptr dw GDT_LIMIT
	dd GDT_BASE

;人工对齐：total_mem_bytes(4)+gdt_ptr(6)+ards_buf(244)+ards_nr(2) 共256字节
ards_buf times 244 db 0
ards_nr dw 0	;用于记录ARDS结构体数量

loadermsg db '2 loader in real.'

loader_start:
;--------------------------------------------------------------------
; int 15h , eax = 0000E820h	edx = 534D4150h ('SMAP') 获取内存布局
	xor ebx, ebx	;第一次调用，ebx置为0
	mov edx, 0x534D4150	;edx只赋值一次，循环体中不会改变
	mov di, ards_buf	;ards结构缓冲区
.e820_mem_get_loop:
	mov eax, 0x0000e820	;执行 int 0x15后， eax值变为 0x534d4150,所以每次执行int前都要更新为子功能号
	mov ecx, 20		;ARDS地址范围描述符结构大小是20字节
	int 0x15
	jc .e820_failed_so_try_e801	;若cf位为1，则有错误发生，尝试0xe801子功能
	add di, cx		;使 di 增加20字节指向缓冲区中新的ARDS结构位置
	inc word [ards_nr]	;记录ARDS 数量
	cmp ebx, 0 		;若 ebx 为0 且 cf不为1，这说明 ards全部返回
	jnz .e820_mem_get_loop

	;在所有ards结构中，找出(base_add_low + length_low)的最大值，既内存的容量
	mov cx,[ards_nr]	;遍历每一个ARDS结构体，循环次数是ARDS的数量
	mov ebx, ards_buf
	xor edx, edx		;edx 为最大的内存容量，在此先清0
.find_max_mem_area:
	mov eax, [ebx]		;base_add_low
	add eax, [ebx + 8]	;length_low
	add ebx, 20		;指向缓冲区中下一个ARDS结构
	cmp edx, eax
	;冒泡排序找出最大，edx寄存器始终是最大的内存容量
	jge .next_ards
	mov edx, eax		;edx 为总内存大小
.next_ards:
	loop .find_max_mem_area
	jmp .mem_get_ok

;------------------------------------------------------------------------
;int 15h    ax = E801h 获取内存大小，最大支持4G
;在 ax 和 cx 值一样，以为KB我单位，bx 和 dx 值一样，以 64KB为单位
;在 ax 和 cx 寄存器中为低16MB ，在 bx 和 dx 寄存器中为 16MB 到 4GB

.e820_failed_so_try_e801:
	mov ax, 0xe801
	int 0x15
	jc .e801_failed_so_try88	;若当前 e801 方法失败，就尝试 0x88方法

;1 先算出低 15MB 的内存, ax 和 cx 中以 KB 为单位的内存数量，将其转换位 byte 为单位
	mov cx, 0x400	;cx 和 ax 值一样，cx用作乘数
	mul cx
	shl edx,16		;edx 低16位移动到高16位
	and eax,0x0000FFFF	;eax 保留低 16位
	or edx,eax		;edx 中的值 来自 eax和edx中各自 16位，16位乘积后是32位，高16在dx，低16在ax中
	add edx, 0x100000	;ax 只是15MB，故要加1MB
	mov esi, edx		;先把低于15MB的内存容量存入 esi寄存器备份		

;2 再将16MB 以上的内存转换为byte为单位，寄存器 bx 和 dx 是以 64KB为单位的内存数量
	xor eax, eax
	mov ax,bx
	mov ecx, 0x10000	;0x10000 十进制为 64KB
	mul ecx			;32位乘法，默认的被成数是 eax，积为64位， 高32位存入 edx,低32位存eax
	add esi,eax		;由于此方法只能检测出 4G以内测内存，所以32位 eax 足够了
	mov edx,esi		;edx 为总内存大小
	jmp .mem_get_ok

;----------------------------------------------------------------------------------
; int 15h ah = 0x88 获取内存大小，只能获取 64MB之内
.e801_failed_so_try88:
	;int 15 后，ax存入的是以 KB 为单位的内存容量
	mov ah, 0x88
	int 0x15
	jc .error_hlt
	and eax, 0x0000FFFF
	;16位乘法，被乘数是ax，积为32位。积的高16位在dx中，积的低16位在 ax 中
	mov cx, 0x400
	mul cx
	shl edx, 16 		;把 dx移到高16位
	or edx, eax		;把积的低 16位 组合到 edx，为32位的积
	add edx, 0x100000	;0x88 子功能只会返回1MB以上的内存，故实际内存大小要加上1MB
	jmp .mem_get_ok

.error_hlt:
	hlt

.mem_get_ok:
	mov [total_mem_bytes], edx

;-----------------------------------------
;INT 0x10 功能号:0x13  功能描述：打印字符
;-----------------------------------------
;输入：
;AH 子功能号=13H
;BH = 页码
;BL = 属性(若AL=00H 或 01H)
;CX = 字符串长度
;(DH,DL) = 坐标（行，列）
;ES:BP = 字符串地址
;AL = 显示输出方式
; 0 ——字符串中只含显示字符，其显示属性在BL中，显示后光标位置不变
; 1 ——字符串中只含显示字符，其显示属性在BL中，显示后光标位置改变
; 2 ——字符串中含显示字符和显示属性。显示后，光标位置不变
; 3 ——字符串中含显示字符和显示属性。显示后，光标位置不变
;无返回值

	mov sp, LOADER_BASE_ADDR
	mov bp, loadermsg	;ES:BP = 字符串地址
	mov cx, 17		;CX = 字符串长度
	mov ax, 0x1301		;AH = 13，AL=01h
	mov bx, 0x001f		;页号为0，蓝底粉红字
	mov dx, 0x1800
	int 0x10		;10h 号中断

;--------------------------准备进入保护模式
;1 打开A20地址线
;2 加载GDT
;3 将CR0寄存器PE位置1

;---------------------打开A20
	in al,0x92
	or al,0000_0010B
	out 0x92,al
;---------------------加载GDT
	lgdt [gdt_ptr]
;---------------------CR0第0位置1
	mov eax, cr0
	or eax,0x00000001
	mov cr0, eax

	jmp  SELECTOR_CODE:p_mode_start	;刷新流水线

[bits 32]
p_mode_start:
	mov ax, SELECTOR_DATA
	mov ds, ax
	mov es, ax
	mov ss, ax
	mov esp, LOADER_STACK_TOP
	mov ax, SELECTOR_VIDEO
	mov gs, ax
	
	mov byte [gs:160], 'p'
	
	jmp $	
